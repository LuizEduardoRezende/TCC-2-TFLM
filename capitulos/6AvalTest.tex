\chapter{Avaliação e Testes}\label{cap:analise}

\section{Metodologia}
Esta seção descreve os procedimentos metodológicos adotados e os recursos empregados para alcançar os objetivos deste trabalho.

\subsection{Software e Hardware}
Os novos recursos e funcionalidades implementados diretamente na linguagem RL foram escritos em C++ e desenvolvidos com o auxílio das ferramentas Flex (versão 2.6.4) e Bison (versão 3.8.2), responsáveis por gerar os analisadores léxico e sintático do Robcmp. Por outro lado, a nova biblioteca padrão foi desenvolvida com a própria linguagem RL, criando um arquivo \texttt{.rob} que continha todas as declarações das funções do \textit{wrapper} C do TFLM.

O ambiente de desenvolvimento foi o Visual Studio Code (versão 1.101), com o auxílio de duas extensões principais: o PlatformIO (versão 6.1.18), para depurar e exportar os \textit{firmwares} para as placas, e o RobCmpSyntax (versão 1.0), que fornece o realce de sintaxe para arquivos .rob.

A máquina de desenvolvimento utilizada foi um \textit{notebook} Lenovo IdeaPad 3 15ITL6, equipado com processador Intel® Core™ i7-1165G7, 16 GB de RAM e sistema operacional Ubuntu 24.04.1 LTS. Além da máquina de desenvolvimento, a execução e validação das aplicações ocorreram em uma placa com o microcontrolador STM32F407VET6, da família STM32, popularmente chamada de Black STM32F407VET6. Essa placa conta com um processador ARM Cortex-M4 rodando a 168 MHz, 192 KB de RAM e 512 KB de memória Flash.

\subsection{Procedimentos de Validação Funcional}
A etapa de validação funcional teve como objetivo verificar se a solução proposta cumpria o que prometia, sem levar em consideração sua eficiência, aplicabilidade, facilidade ou qualquer outro fator que mede sua qualidade.

Nesta etapa, as novas funcionalidades foram validadas utilizando testes unitários, que foram executados tanto na máquina de desenvolvimento quanto na placa Black STM32F407VET6. Esses testes foram projetados para verificar se cada nova funcionalidade implementada no Robcmp estava operando conforme o esperado. Foram criados diversos arquivos \texttt{.rob} que utilizavam diferentes modelos de ML, abrangendo uma variedade de cenários e casos de uso. Os testes foram desenvolvidos utilizando tanto a linguagem RL com as novas palavras-chave quanto a biblioteca padrão, localizada no diretório \texttt{lib/ai/tflm.rob}.

\subsection{Validação da eficiência e Análise Comparativa}
Para validar a eficiência da integração do TFLM à RL, foi realizada uma análise comparativa entre três abordagens de desenvolvimento de firmwares: os desenvolvidos com a nova sintaxe da RL, os que utilizaram a biblioteca padrão do Robcmp para TinyML e os desenvolvidos diretamente em C++ utilizando o ambiente do TFLM.

Para garantir uma avaliação justa, ambos os testes foram conduzidos em um MCU idêntico e com o mesmo modelo de ML. Nesta avaliação, foram considerados critérios como a facilidade de desenvolvimento, a manutenibilidade do código, o tempo de execução e o tamanho final do executável.

\section{Configuração do Ambiente Experimental}\label{sec:ambiente-experimental}

\lstdefinestyle{terminal-abnt}{
    language={},                        
    backgroundcolor=\color{listbggray}, 
    basicstyle=\ttfamily\small,         
    keywordstyle=,                      % Estilo de keyword (vazio)
    stringstyle=,                       % Estilo de string (vazio)
    numbers=none,                       % Números de linha à esquerda
    numberstyle=\tiny,                  % Estilo do número (sem cor)
    numbersep=5pt,                      % Distância dos números
    frame=none,                         % Sem bordas (como no seu main.pdf)
    captionpos=t,                       % Posição da legenda (t = top), como no seu main.pdf
    breaklines=true,                    % Quebra linhas longas
    breakatwhitespace=true,             % Quebra apenas em espaços
    showstringspaces=false,             % Não mostra símbolos para espaços
    tabsize=2                           % Tamanho do TAB
}
\newtcblisting{abntbox}{
    enhanced,
    listing only,
    colback=listbggray,     
    colframe=listbggray,    
    arc=3mm,                
    left=2mm,
    right=2mm,
    top=2mm,
    bottom=2mm,
    fonttitle=\bfseries,
    coltitle=black,         
    listing options={style=terminal-abnt}
}

Esta seção detalha os passos necessários para configurar o ambiente de desenvolvimento, compilar o fork do Robcmp e replicar o sistema de build utilizado nos experimentos. 

No futuro, um novo desenvolvedor não precisará seguir estes passos pois o Robcmp já estará com o processo de compilação para programas que utilizam do TFLM automatizado e integrado ao Platoformio com VS Code, da mesma forma que já está para programas embarcados convencionais. Porém, esta seção é valiosa para trabalhos futuros que desejem modificar o compilador Robcmp ou entender melhor sua integração com o TFLM.

\subsection{Pré-requisitos de Software}
Antes de iniciar, é necessário garantir que os seguintes pacotes de software estejam instalados no sistema (preferencialmente um ambiente Linux, como o Ubuntu):

\begin{itemize}
    \item Git: Para controle de versão e download do repositório.
    \item Cmake: Para configurar o sistema de build do Robcmp.
    \item Make: Para executar os scripts de compilação.
    \item Clang: Um compilador C++ moderno.
    \item Flex: (versão 2.6.4 ou similar): Gerador de analisador léxico.
    \item Bison: (versão 3.8.2 ou similar): Gerador de analisador sintático.
\end{itemize}

A maioria desses pacotes pode ser instalada em sistemas baseados em Debian/Ubuntu com os comandos:

\begin{lstlisting}[style=terminal-abnt]
sudo apt-get update
sudo apt-get install git cmake make g++ flex bison
\end{lstlisting}

\begin{abntbox}
sudo apt-get update
sudo apt-get install git cmake make g++ flex bison
\end{abntbox}

\subsection{Download do Repositório e Submódulos}
O fork do Robcmp utiliza submódulos do Git para gerenciar a dependência do TFLM. É necessário iniciar o submódulo existente após o clone com os seguintes comandos:

\begin{abntbox}
# Clona o repositorio fork do Robcmp
git clone https://github.com/LuizEduardoRezende/robcmp.git

# Navega ate o diretorio do repositorio
cd robcmp

# Seleciona a branch com o frontend do TFLM
git checkout tflm-front-end

# Inicializa e atualiza os submodulos
git submodule update --init --recursive
\end{abntbox}

Talvez seja necessário atualizar o seu explorador de arquivos para vizualiar os novos arquivos criados, após a inicialização e atualização dos submódulos.

\subsection{Processo de Compilação (\textit{Build})}
O processo de compilação é dividido em duas etapas, conforme a arquitetura descrita na \hyperref[sec:arq-camada-compatibilidade]{Seção~\ref{sec:arq-camada-compatibilidade}}. Primeiro, compila-se a biblioteca estática do TFLM; em seguida, compila-se o Robcmp (que inclui o \textit{wrapper} C).

Caso esteja buscando compilar para uma arquitetura especifica (ex: Cortex-M4), é possível verificar todas as arquiteturas suportadas pelo TFLM na documentação do \textit{GitHub} \footnote{\url{https://github.com/tensorflow/tflite-micro/blob/main/tensorflow/lite/micro/cortex_m_generic/README.md}}.

Com uma arquitetura específica em mente, navegue até o diretório do submódulo do TFLM, depois use o sistema de Makefile do TFLM para compilar a biblioteca para a arquitetura desejada:

\begin{abntbox}
# Navega ate o diretorio do TFLM
cd third_party/tflite-micro/

# Compila para uma plataforma especifica
make -f tensorflow/lite/micro/tools/make/Makefile TARGET=cortex_m_generic TARGET_ARCH=cortex-m4 microlite

# Compila para a plataforma de sua maquina de desenvolvimento(linux, windows, etc)
make -f tensorflow/lite/micro/tools/make/Makefile microlite
\end{abntbox}

Ao final deste processo, a biblioteca estática com nome padronizado deverá estar presente no diretório \texttt{third-party/\allowbreak tflite-micro/\allowbreak gen/\allowbreak (nome-da-arquitetura)/\allowbreak lib/\allowbreak libtensorflow-microlite.a}. Talvez seja necessário atualizar o seu explorador de arquivos para vizualiar os novos arquivos criados.

Atenção, caso tenha feito a compilação de mais de uma biblioteca estática do TFLM, escolha apenas uma arquitetura para trabalhar por vez. Para que o build e a configuração do ambiente de desenvolvimento ocorram corretamente é necessário que exista apenas uma arquitetura dentro de \texttt{third-party/tflite-micro/gen}. Caso deseje trabalhar com multiplas arquiteturas, é recomendado que se crie cópias do repositório do Robcmp para cada arquitetura desejada.

Com a biblioteca TFLM pronta, retorne ao diretório raiz do robcmp para compilar o projeto principal utilizando o Cmake e o Make:

\begin{abntbox}
# Cria o diretorio de build e navega ate ele
mkdir build
cd build

# Configura o projeto
cmake ..

# Compila o projeto (use -j para compilacao paralela, ex: -j6)
make
\end{abntbox}

Se a compilação for bem-sucedida, o executável do compilador (robcmp) estará disponível dentro do diretório \texttt{build}, pronto para ser usado nos testes de validação.

\subsection{Compilação de arquivos .rob que usam o TFLM (\texttt{Makefile.tflm})}

Para conseguir compilar um programa \texttt{.rob} criado ou já existente basta utilizar o \texttt{Makefile.tflm} localizado na raíz do Robcmp. Este Makefile consegue compilar programas que estejam localizados dentro da pasta \texttt{test/tflm-tests}. A partir da raíz do projeto Robcmp, utilize os seguintes comandos:

\begin{abntbox}
# Mostra todos os comandos disponiveis 
make -f Makefile.tflm help

# Compila e gera o executavel na pasta build
make -f Makefile.tflm FILE=syntax-spam

# Remove os arquivos gerados desse programa
make -f Makefile.tflm FILE=syntax-spam clean

# Remove os arquivos objeto(.o) gerados por programas
make -f Makefile.tflm clean-all

# Executa o programa que foi gerado na pasta build
./build/syntax-spam
\end{abntbox}


\section{Validação Funcional}

\section{Validação da eficiência e Análise Comparativa}

\section{Considerações Finais}



