\chapter{Avaliação e Testes}\label{cap:analise}

Este capítulo abordará tudo relacionado ao processo de avaliação e testes da solução proposta. Inicialmente, serão descritos os procedimentos metodológicos adotados, incluindo também quais foram os recursos utilizados na execução dos testes, como hardware, software e outras ferramentas relevantes. Em seguida, será detalhada a configuração do ambiente experimental, fornecendo informações sobre como replicar o ambiente utilizado para os testes. Por fim, serão apresentados os resultados obtidos durante os testes, acompanhados de uma análise crítica e uma discussão final sobre os resultados.

\section{Metodologia}

Esta seção descreve a metodologia adotada para avaliação e testes da solução, apresentando o ambiente de desenvolvimento (software e hardware), bem como os procedimentos de validação funcional e a análise comparativa de eficiência.

\subsection{Software e Hardware}
Os novos recursos e funcionalidades implementados diretamente na linguagem RL foram desenvolvidos com o auxílio das ferramentas Flex (versão 2.6.4) e Bison (versão 3.8.2), responsáveis por gerar os analisadores léxico e sintático do Robcmp. Além disso, a análise semântica foi escrita em C++ conforme a estrutura do compilador. Por outro lado, a nova biblioteca padrão foi desenvolvida com a própria linguagem RL, criando um arquivo \texttt{.rob} que continha todas as declarações das funções do \textit{wrapper} C do TFLM.

O ambiente de desenvolvimento foi o Visual Studio Code (versão 1.101), com o auxílio de duas extensões principais: o PlatformIO (versão 6.1.18), para depurar e exportar os \textit{firmwares} para as placas, e o RobCmpSyntax (versão 1.0), que fornece o realce de sintaxe para arquivos .rob.

A máquina de desenvolvimento utilizada foi um \textit{notebook} Lenovo IdeaPad 3 15ITL6, equipado com processador Intel® Core™ i7-1165G7, 16 GB de RAM e sistema operacional Ubuntu 24.04.1 LTS. Além da máquina de desenvolvimento, a execução e validação das aplicações ocorreram em uma placa com o microcontrolador STM32F407VET6, da família STM32, popularmente chamada de Black STM32F407VET6. Essa placa conta com um processador ARM Cortex-M4 rodando a 168 MHz, 192 KB de RAM e 512 KB de memória Flash.

\subsection{Procedimentos de Validação Funcional}
A etapa de validação funcional teve como objetivo verificar se a solução proposta cumpria o que prometia, sem levar em consideração sua eficiência, aplicabilidade, facilidade ou qualquer outro fator que mede sua qualidade.

Nesta etapa, as novas funcionalidades foram validadas utilizando testes unitários, que foram executados tanto na máquina de desenvolvimento quanto na placa com o MCU. Esses testes foram projetados para verificar se cada nova funcionalidade implementada no Robcmp estava operando conforme o esperado. Foram criados diversos arquivos \texttt{.rob} que utilizavam diferentes modelos de ML, abrangendo uma variedade de cenários e casos de uso. Os testes foram desenvolvidos utilizando tanto a linguagem RL com as novas palavras-chave quanto a biblioteca padrão.

\subsection{Validação da eficiência e Análise Comparativa}
Para validar a eficiência da integração do TFLM à RL, foi realizada uma análise comparativa entre três abordagens de desenvolvimento de firmwares: os desenvolvidos com a nova sintaxe da RL, os que utilizaram a biblioteca padrão do Robcmp para TinyML e os desenvolvidos diretamente em C++ utilizando o ambiente do TFLM.

Para garantir uma avaliação justa, ambos os testes foram conduzidos em um MCU idêntico e com o mesmo modelo de ML. Nesta avaliação, foram considerados critérios como a facilidade de desenvolvimento, a manutenibilidade do código, o tempo de execução e o tamanho final do executável.

\section{Configuração do Ambiente Experimental}\label{sec:ambiente-experimental}

\lstdefinestyle{terminal-abnt}{
    language={},                        
    backgroundcolor=\color{listbggray}, 
    basicstyle=\ttfamily\small,         
    keywordstyle=,                      % Estilo de keyword (vazio)
    stringstyle=,                       % Estilo de string (vazio)
    numbers=none,                       % Números de linha à esquerda
    numberstyle=\tiny,                  % Estilo do número (sem cor)
    numbersep=5pt,                      % Distância dos números
    frame=none,                         % Sem bordas (como no seu main.pdf)
    captionpos=t,                       % Posição da legenda (t = top), como no seu main.pdf
    breaklines=true,                    % Quebra linhas longas
    breakatwhitespace=true,             % Quebra apenas em espaços
    showstringspaces=false,             % Não mostra símbolos para espaços
    tabsize=2                           % Tamanho do TAB
}
\newtcblisting{abntbox}{
    enhanced,
    listing only,
    colback=listbggray,     
    colframe=listbggray,    
    arc=3mm,                
    left=2mm,
    right=2mm,
    top=2mm,
    bottom=2mm,
    fonttitle=\bfseries,
    coltitle=black,         
    listing options={style=terminal-abnt}
}

Esta seção detalha os passos necessários para configurar o ambiente de desenvolvimento, isto envolve compilar o fork do Robcmp e replicar o sistema de build utilizado nos experimentos. 

No futuro, um novo desenvolvedor não precisará seguir estes passos pois o Robcmp já disponibilizará todas as possíveis bibliotecas pré-compiladas do \textit{wrapper} e do TFLM. Assim, o processo de desenvolvimento poderá ser feito através de forma automática e integrada ao PlatformIO, da mesma forma que já ocorre para programas embarcados convencionais. 

Porém, esta seção é ainda é valiosa por ensinar o processo de instalação dos pacotes necessários, clonagem correta do repositório e compilação do Robcmp, tarefas obrigatórias para um novo desenvolvedor. Além disso, esta seção é útil para trabalhos futuros que desejem modificar o compilador Robcmp ou entender melhor sua integração com o TFLM.

\subsection{Pré-requisitos de Software}
Antes de iniciar, é necessário garantir que os seguintes pacotes de software estejam instalados no sistema (preferencialmente um ambiente Linux, como o Ubuntu):

\begin{itemize}
    \item Git: Para controle de versão e download do repositório.
    \item CMake: Para configurar o sistema de build do Robcmp.
    \item Make: Para executar os scripts de compilação.
    \item LLVM (versão 20+): Conjunto de ferramentas e bibliotecas para compilação.
    \item Clang (versão 20+): Compilador C/C++ baseado no LLVM.
    \item Flex (versão 2.6.4 ou similar): Gerador de analisador léxico.
    \item Bison (versão 3.8.2 ou similar): Gerador de analisador sintático.
\end{itemize}

A maioria desses pacotes pode ser instalada em sistemas baseados em Debian/Ubuntu com os comandos:

% \begin{lstlisting}[style=terminal-abnt]
% sudo apt-get update
% sudo apt-get install git cmake make g++ flex bison
% \end{lstlisting}

\begin{abntbox}
sudo apt-get update
sudo apt-get install git cmake make clang llvm flex bison
\end{abntbox}

\subsection{Download do Repositório e Submódulos}
O fork do Robcmp utiliza submódulos do Git para gerenciar a dependência do TFLM. É necessário iniciar o submódulo existente após o clone com os seguintes comandos:

\begin{abntbox}
# Clona o repositorio fork do Robcmp
git clone https://github.com/LuizEduardoRezende/robcmp.git

# Navega ate o diretorio do repositorio
cd robcmp

# Seleciona a branch com o frontend do TFLM
git checkout tflm-front-end

# Inicializa e atualiza os submodulos
git submodule update --init --recursive
\end{abntbox}

Talvez seja necessário atualizar o seu explorador de arquivos para vizualiar os novos arquivos criados, após a inicialização e atualização dos submódulos.

\subsection{Processo de Compilação (\textit{Build})}
O processo de compilação é dividido em duas etapas, conforme a arquitetura descrita na \hyperref[sec:arq-camada-compatibilidade]{Seção~\ref{sec:arq-camada-compatibilidade}}. Primeiro, compila-se a biblioteca estática do TFLM; em seguida, compila-se o Robcmp (que inclui o \textit{wrapper} C).

Caso esteja buscando compilar para uma arquitetura especifica (ex: Cortex-M4), é possível verificar todas as arquiteturas suportadas pelo TFLM na documentação do \textit{GitHub} \footnote{\url{https://github.com/tensorflow/tflite-micro/blob/main/tensorflow/lite/micro/cortex_m_generic/README.md}}.

Com uma arquitetura específica em mente, navegue até o diretório do submódulo do TFLM, depois use o sistema de Makefile do TFLM para compilar a biblioteca para a arquitetura desejada:

\begin{abntbox}
# Navega ate o diretorio do TFLM
cd third_party/tflite-micro/

# Compila para uma plataforma especifica
make -f tensorflow/lite/micro/tools/make/Makefile TARGET=cortex_m_generic TARGET_ARCH=cortex-m4 microlite

# Compila para a plataforma de sua maquina de desenvolvimento(linux, windows, etc)
make -f tensorflow/lite/micro/tools/make/Makefile microlite
\end{abntbox}

Ao final deste processo, a biblioteca estática com nome padronizado deverá estar presente no diretório \texttt{third-party/\allowbreak tflite-micro/\allowbreak gen/\allowbreak (nome-da-arquitetura)/\allowbreak lib/\allowbreak libtensorflow-microlite.a}. Talvez seja necessário atualizar o seu explorador de arquivos para vizualiar os novos arquivos criados.

Atenção, caso tenha feito a compilação de mais de uma biblioteca estática do TFLM, escolha apenas uma arquitetura para trabalhar por vez. Para que o build e a configuração do ambiente de desenvolvimento ocorram corretamente é necessário que exista apenas uma arquitetura dentro de \texttt{third-party/tflite-micro/gen}. Caso deseje trabalhar com multiplas arquiteturas, é recomendado que se crie cópias do repositório do Robcmp para cada arquitetura desejada.

Com a biblioteca TFLM pronta, retorne ao diretório raiz do robcmp para compilar o projeto principal utilizando o CMake e o Make:

\begin{abntbox}
# Cria o diretorio de build e navega ate ele
mkdir build
cd build

# Configura o projeto
cmake ..

# Compila o projeto (use -j para compilacao paralela, ex: -j6)
make
\end{abntbox}

Se a compilação for bem-sucedida, o executável do compilador (arquivo \texttt{robcmp}) estará disponível dentro do diretório \texttt{build}, pronto para ser usado nos testes de validação.

\subsection{Compilação de arquivos .rob que usam o TFLM (\texttt{Makefile.tflm})}

Para conseguir compilar um programa \texttt{.rob} criado ou já existente basta utilizar o \texttt{Makefile.tflm} localizado na raíz do Robcmp. Este Makefile consegue compilar programas que estejam localizados dentro da pasta \texttt{test/tflm-tests}. A partir da raíz do projeto Robcmp, utilize os seguintes comandos:

\begin{abntbox}
# Mostra todos os comandos disponiveis 
make -f Makefile.tflm help

# Compila e gera o executavel na pasta build
make -f Makefile.tflm FILE=syntax-spam

# Remove os arquivos gerados desse programa
make -f Makefile.tflm FILE=syntax-spam clean

# Remove os arquivos objeto(.o) gerados por programas
make -f Makefile.tflm clean-all

# Executa o programa que foi gerado na pasta build
./build/syntax-spam
\end{abntbox}

\section{Resultados da Validação Funcional}
Como o objetivo da validação funcional era garantir que as novas funcionalidades implementadas estivessem operando conforme o esperado, foram criados diversos arquivos \texttt{.rob} que utilizavam diferentes modelos de ML, abrangendo uma variedade de cenários e casos de uso.

A maioria dos testes unitários do Robcmp estão presentes na pasta \texttt{test/general} e são executados automaticamente através do Makefile e de um script \texttt{run-tests.sh}. No caso dos testes unitários relacionados ao TFLM, estes estão localizados na pasta \texttt{test/tflm-tests}. Essa separação foi necessária pois o processo de linkedição dos programas que utilizam o TFLM é diferente dos programas convencionais, exigindo a inclusão da biblioteca estática do TFLM e do \textit{wrapper} C.

Dentro do diretório de testes desejado, basta executar o comando \texttt{make} para que todos os testes sejam compilados e executados automaticamente. Foram desenvolvidos testes unitários tanto utilizando a nova sintaxe da RL quanto utilizando a biblioteca padrão do Robcmp para TinyML. Como convenção, os arquivos de teste que utilizam a nova sintaxe possuem o prefixo \texttt{syntax-}, enquanto os que utilizam a biblioteca padrão possuem o prefixo \texttt{lib-}.

Dois arquivos de exemplo foram colocados nos apêndices no final deste trabalho que realizam os testes unitários com o modelo de classificação de spam. O \hyperref[]{Código~\ref*{}} apresenta o arquivo \texttt{syntax-spam.rob}, que utiliza a nova sintaxe da RL, enquanto o \hyperref[lst:teste-bib-rob]{Código~\ref*{lst:teste-bib-rob}} apresenta o arquivo \texttt{lib-spam.rob}, que utiliza a biblioteca padrão.

Esses testes verificam se o modelo de ML é carregado corretamente, se as entradas são processadas adequadamente e se as saídas correspondem ao esperado, entre outros aspectos. Ambos os arquivos foram compilados e executados com sucesso, confirmando o correto funcionamento das novas funcionalidades.

\section{Resultados da Validação da Eficiência e Análise Comparativa}


\begin{table}[h]
\centering 
\caption{Tamanho do código objeto em \textit{bytes}}
\label{comparativo}
    \begin{tabular}{cccc}
    \toprule
    \textbf{Modelo TinyML} & \textbf{Sintaxe} & \textbf{Biblioteca padrão} & \textbf{TFLM(C++)}  \\ \midrule
    Classificador de Spam   \\ 
    Preditor de Seno quantizado \\
    Preditor de Seno  \\ 
    \bottomrule
    
    \end{tabular}
\end{table}

\begin{table}[h]
\centering 
\caption{Tempo de execução, em milissegundos}
\label{comparativo}
    \begin{tabular}{cccc}
    \toprule
    \textbf{Modelo TinyML} & \textbf{Sintaxe} & \textbf{Biblioteca padrão} & \textbf{TFLM(C++)}  \\ \midrule
    Classificador de Spam   \\ 
    Preditor de Seno quantizado \\
    Preditor de Seno  \\ 
    \bottomrule
    
    \end{tabular}
\end{table}

\section{Considerações Finais}



