%% abtex2-modelo-projeto-pesquisa.tex, v-1 marcoswagner PFC 2 2023
%% Copyright 2020-2023 by abnTeX2 group at BCC-UFJ http://www.abntex.net.br/ 
%%
%% This work consists of the files abntex2-modelo-projeto-pesquisa.tex
%% and abntex2-modelo-references.bib
%%

% ---------------------------------------------------------------------
% ---------------------------------------------------------------------
% abnTeX2: Modelo Adaptado de Monografia em conformidade com 
% ABNT NBR 15287:2011 Informação e documentação - Monografia 
% --------------------------------------------------------------------- 
% ---------------------------------------------------------------------
\documentclass[
	12pt,				
	oneside,
	a4paper,		
    sumario=tradicional,
	english,			
	french,				
	spanish,			
	brazil,				
	documento
	]{abntex2}

% ---
% Configurações
% ---
\usepackage{abntex2/abntex2-bcc-ufj}
\renewcommand*\arraystretch{1.2} 
\usepackage{pdfpages} %para incluir pdf como páginas


% ---
% Pacotes básicos 
% ---
\usepackage{lmodern}					
\usepackage[T1]{fontenc}		
\usepackage[utf8]{inputenc}	
\usepackage{lastpage}		
\usepackage{indentfirst}	
\usepackage{color}			
\usepackage{graphicx}		
\usepackage{microtype} 		
\usepackage[htt]{hyphenat} % Permite quebra de linha em texttt
\usepackage{seqsplit}      % Permite quebra de palavras longas arbitrariamente
% ---

% ---
% Pacotes adicionais,
% ---
\usepackage{lipsum}	
\usepackage{caption}
\usepackage{subcaption}
\usepackage{enumerate} 
\usepackage{listings}     
\usepackage{float}
\usepackage{roblang}

\usepackage{booktabs}
\usepackage{makecell}

\usepackage{xcolor}
\usepackage{tcolorbox}
\tcbuselibrary{listings}
\tcbuselibrary{skins}
\tcbuselibrary{breakable}
\definecolor{listbggray}{rgb}{0.95,0.95,0.95} % Fundo cinza claro para listings

\lstdefinelanguage{Bison}{
sensitive=true,
morekeywords={\%token,\%left,\%right,\%nonassoc,\%union,\%type,\%start,\%prec, |},
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morestring=[b]",
alsoletter={_\%} 
}

\lstdefinestyle{Bison}{
    language=Bison,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    numbers=left,
    stepnumber=1,
    breaklines=true,
    showstringspaces=false,
    tabsize=4,
    emph={},
    literate={\$}{{\$}}1 {@}{{@}}1 {\{}{{\{}}1 {\}}{{\}}}1,
}

% --- 
% CONFIGURAÇÕES DE PACOTES
% --- 
\include{comandos}

% ---
% Informações de dados para CAPA e FOLHA DE ROSTO
% ---
\input{custom}
% ---

%% \includeonly{capitulos/1RefTeorico}

%%%%%%%%%=============== DOCUMENTO ===========%%%%%%%%%%%
% ----
% Início do documento
% ----
\begin{document}
\selectlanguage{brazil}
% Retira espaço extra obsoleto entre as frases.
\frenchspacing 

% ----------------------------------------------------------
% ELEMENTOS PRÉ-TEXTUAIS
% ----------------------------------------------------------
% \pretextual

% ---
% Capa
% ---
\imprimircapa
% ---

% ---
% Folha de rosto
% ---
\imprimirfolhaderosto
% ---


% ---
% Ficha Catalográfica
\begin{fichacatalografica}
    \includepdf{FichaCatalografica}
\end{fichacatalografica}


% ---
% Inserir folha de aprovação
% ---
\includepdf{aprova}


% ---
% Dedicatória/Agradecimentos/Epígrafe
% ---
\include{agrad_dec_ep}

% ---
% RESUMOS
% ---
\include{resumos}

% ---

% ---
% inserir lista de ilustrações
% ---
\pdfbookmark[0]{\listfigurename}{lof}
\listoffigures*
\cleardoublepage
% ---

% ---
% inserir lista de tabelas
% ---
\pdfbookmark[0]{\listtablename}{lot}
\listoftables*
\cleardoublepage
% ---

% ---
% inserir lista de abreviaturas e siglas
% ---
\begin{siglas}

\item[AF] Autômato Finito
\item[AIfES] Artificial Intelligence for Embedded Systems
\item[API] Application Programming Interface
\item[ARM] Advanced RISC Machine
\item[AST] Árvore Sintática Abstrata
\item[AVR] Alf and Vegard’s RISC processor
\item[CFG] Context-Free Grammar
\item[CPU] Central Processing Unit
\item[DSP] Digital Signal Processor
\item[IA] Inteligência Artificial
\item[IoT] Internet of Things
\item[IR] Intermediate Representation
\item[MCU] Microcontroller Unit
\item[ML] Machine Learning
\item[RAM] Random access memory
\item[RE] Regular Expression
\item[RL] Robotics Language
\item[TFLM] TensorFlow Lite Micro
\item[UFJ] Universidade Federal de Jataí 

\end{siglas}
% ---


% ---
% inserir o sumario
% ---
\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*
\cleardoublepage
% ---

% ===================================================
% ELEMENTOS TEXTUAIS - Capítulos ----
% ----------------------------------------------------------
\textual

\include{capitulos/0Introd}
\include{capitulos/1RefTeorico}
\include{capitulos/2TrabRelac}
\include{capitulos/4ImpConst}

%\include{capitulos/5FuncDemo}

\include{capitulos/6AvalTest}
\include{capitulos/7ConcTrabFut}

% ----------------------------------------------------------
% ELEMENTOS PÓS-TEXTUAIS
% ----------------------------------------------------------
\postextual
% ----------------------------------------------------------

% ----------------------------------------------------------
% Referências bibliográficas
% ----------------------------------------------------------
\bibliography{bib}

% ----------------------------------------------------------
% Apêndices
% ----------------------------------------------------------


% ----------------------------------------------------------
% Anexos
% ----------------------------------------------------------

% ---
% Inicia os anexos
% ---
% ---
% Inicia os anexos
% ---
\begin{anexosenv}

% Imprime uma página indicando o início dos anexos
\partanexos

\chapter{Testes Unitários}\label{apendice:teste-sintaxe}

\begin{lstlisting}[style=rob, caption={Teste unitário do modelo classificador de spam com a biblioteca padrão \texttt{tflm.rob}}, label={lst:teste-bib-rob}]
use ai.tflm;

spam_model_data = {0x1c,0x0,0x0,0x0,0x54
// (Conteudo do modelo em bytes omitido para brevidade)
};

spam_model_data_size = 83304;

// Arena de memoria para tensores (16KB para garantir espaco suficiente)
tensor_arena = {0u:4096};

// Kernels necessarios para o modelo Spam, Gather, Mean, FullyConnected e Softmax
required_kernels = {36, 40, 9, 25};


int8 test_init() {
    h = InitializeInterpreter(spam_model_data, tensor_arena, required_kernels);
    if(h == 0){ 
        return 1;
    }
    DestroyInterpreter(h);
    return 0;
}

// Testa inferencia para frase nao SPAM
int8 test_infer_not_spam() {
    h = InitializeInterpreter(spam_model_data, tensor_arena, required_kernels);
    if(h == 0) {
        return 1;
    }

    in = GetInputTensor(h, 0);
    out = GetOutputTensor(h, 0);

    if(in == 0 or out == 0) {
        DestroyInterpreter(h);
        return 2;
    }
    // "This is a great article thank you for the information"
    dados = {1.0, 82.0, 70.0, 214.0, 55.0, 98.0, 84.0, 47.0, 89.0, 26.0, 73.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
    output = {0.0, 0.0};

    SetTensorArray(in, dados, 20);
    InvokeInterpreter(h);
    GetTensorArray(out, output, 2);
    DestroyInterpreter(h);

    PrintFloat(output[1]);

    if (output[1] > 0.1) {
        return 3;
    }
    return 0;
}

// Testa inferencia para frase SPAM
int8 test_infer_spam() {
    h = InitializeInterpreter(spam_model_data, tensor_arena, required_kernels);
    if(h == 0) {
        return 1;
    }

    in = GetInputTensor(h, 0);
    out = GetOutputTensor(h, 0);

    if(in == 0 or out == 0) {
        DestroyInterpreter(h);
        return 2;
    }
    // Frase: "win free money online click www site com"
    dados = {1.0, 93.0, 326.0, 72.0, 8.0, 485.0, 24.0, 35.0, 6.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
    output = {0.0, 0.0};

    SetTensorArray(in, dados, 20);
    InvokeInterpreter(h);
    GetTensorArray(out, output, 2);
    DestroyInterpreter(h);

    PrintFloat(output[1]);

    if(output[1] < 0.90) {
        return 3;
    }
    return 0;
}

// Testa falha ao obter tensor de entrada (indice invalido)
int8 test_input_tensor_fail() {
    h = InitializeInterpreter(spam_model_data, tensor_arena, required_kernels);
    if(h == 0) {
        return 1;
    }
    in = GetInputTensor(h, 99); // indice invalido
    DestroyInterpreter(h);
    if(in != 0) {
        return 2;
    }
    return 0;
}

// Testa falha ao obter tensor de saida (indice invalido)
int8 test_output_tensor_fail() {
    h = InitializeInterpreter(spam_model_data, tensor_arena, required_kernels);
    if(h == 0) {
        return 1;
    }
    out = GetOutputTensor(h, 99); // indice invalido
    DestroyInterpreter(h);
    if(out != 0) {
        return 2;
    }
    return 0;
}

// Executa todos os testes unitarios
int8 main() {
    result = 0;

    if(test_init() != 0){ result = 1;}
    if(test_infer_not_spam() != 0) {result = 2;}
    if(test_infer_spam() != 0) {result = 3;}
    if(test_input_tensor_fail() != 0) {result = 4;}
    if(test_output_tensor_fail() != 0) {result = 5;}

    PrintFloat(float(result));

    return result; // Todos passaram
}
\end{lstlisting}

\begin{lstlisting}[style=cpp, caption={Teste unitário do modelo classificador de spam em C++ com o TFLM}, label={lst:teste-cpp}]
#include "tensorflow/lite/core/c/common.h"
#include "tensorflow/lite/micro/examples/firmware_spam_detector/models/spam_model_data.h"
#include "tensorflow/lite/micro/micro_interpreter.h"
#include "tensorflow/lite/micro/micro_log.h"
#include "tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "tensorflow/lite/micro/system_setup.h"
#include "tensorflow/lite/schema/schema_generated.h"

namespace {
using SpamDetectorOpResolver = tflite::MicroMutableOpResolver<4>;

TfLiteStatus RegisterOps(SpamDetectorOpResolver& op_resolver) {
  TF_LITE_ENSURE_STATUS(op_resolver.AddGather());
  TF_LITE_ENSURE_STATUS(op_resolver.AddMean());
  TF_LITE_ENSURE_STATUS(op_resolver.AddFullyConnected());
  TF_LITE_ENSURE_STATUS(op_resolver.AddSoftmax());
  return kTfLiteOk;
}
}  // namespace

// Global variables for tests
constexpr int kTensorArenaSize = 4 * 1024;
uint8_t tensor_arena[kTensorArenaSize];
SpamDetectorOpResolver op_resolver;

// Test sentences
int32_t test_sentence_1[20] = {1, 82, 70, 214, 55, 98, 84, 47, 89, 26, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0}; // "This is a great article thank you for the information"
int32_t test_sentence_2[20] = {1, 93, 326, 72, 8, 485, 24, 35, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; // "win free money online click www site com"

// Test initialization
int test_init() {
  TF_LITE_ENSURE_STATUS(RegisterOps(op_resolver));
  
  const tflite::Model* model = ::tflite::GetModel(g_spam_model_data);
  if (model->version() != TFLITE_SCHEMA_VERSION) {
    return 1;
  }
  
  tflite::MicroInterpreter interpreter(model, op_resolver, tensor_arena, kTensorArenaSize);
  if (interpreter.AllocateTensors() != kTfLiteOk) {
    return 1;
  }
  
  return 0;
}

// Test inference for non-spam sentence
int test_infer_non_spam() {
  const tflite::Model* model = ::tflite::GetModel(g_spam_model_data);
  if (model->version() != TFLITE_SCHEMA_VERSION) {
    return 1;
  }
  
  tflite::MicroInterpreter interpreter(model, op_resolver, tensor_arena, kTensorArenaSize);
  if (interpreter.AllocateTensors() != kTfLiteOk) {
    return 1;
  }
  
  TfLiteTensor* input = interpreter.input(0);
  TfLiteTensor* output = interpreter.output(0);
  
  if (input == nullptr || output == nullptr) {
    return 2;
  }
  
  // Set non-spam sentence
  for (int j = 0; j < 20; ++j) {
    input->data.i32[j] = test_sentence_1[j];
  }
  
  if (interpreter.Invoke() != kTfLiteOk) {
    return 2;
  }
  
  float not_spam_prob = output->data.f[0];
  float spam_prob = output->data.f[1];
  
  MicroPrintf("test_infer_non_spam: not_spam_prob=%f, spam_prob=%f", (double)not_spam_prob, (double)spam_prob);
  
  // Expect non-spam probability to be higher
  if (spam_prob > not_spam_prob) {
    return 3;
  }
  
  return 0;
}

// Test inference for spam sentence
int test_infer_spam() {
  const tflite::Model* model = ::tflite::GetModel(g_spam_model_data);
  if (model->version() != TFLITE_SCHEMA_VERSION) {
    return 1;
  }
  
  tflite::MicroInterpreter interpreter(model, op_resolver, tensor_arena, kTensorArenaSize);
  if (interpreter.AllocateTensors() != kTfLiteOk) {
    return 1;
  }
  
  TfLiteTensor* input = interpreter.input(0);
  TfLiteTensor* output = interpreter.output(0);
  
  if (input == nullptr || output == nullptr) {
    return 2;
  }
  
  // Set spam sentence
  for (int j = 0; j < 20; ++j) {
    input->data.i32[j] = test_sentence_2[j];
  }
  
  if (interpreter.Invoke() != kTfLiteOk) {
    return 2;
  }
  
  float not_spam_prob = output->data.f[0];
  float spam_prob = output->data.f[1];
  
  MicroPrintf("test_infer_spam: not_spam_prob=%f, spam_prob=%f", (double)not_spam_prob, (double)spam_prob);
  
  // Expect spam probability to be higher
  if (not_spam_prob > spam_prob) {
    return 3;
  }
  
  return 0;
}

// Test failure when getting input tensor (invalid index)
int test_input_tensor_fail() {
  const tflite::Model* model = ::tflite::GetModel(g_spam_model_data);
  if (model->version() != TFLITE_SCHEMA_VERSION) {
    return 1;
  }
  
  tflite::MicroInterpreter interpreter(model, op_resolver, tensor_arena, kTensorArenaSize);
  if (interpreter.AllocateTensors() != kTfLiteOk) {
    return 1;
  }
  
  TfLiteTensor* input = interpreter.input(99); // invalid index
  
  if (input != nullptr) {
    return 2;
  }
  
  return 0;
}

// Test failure when getting output tensor (invalid index)
int test_output_tensor_fail() {
  const tflite::Model* model = ::tflite::GetModel(g_spam_model_data);
  if (model->version() != TFLITE_SCHEMA_VERSION) {
    return 1;
  }
  
  tflite::MicroInterpreter interpreter(model, op_resolver, tensor_arena, kTensorArenaSize);
  if (interpreter.AllocateTensors() != kTfLiteOk) {
    return 1;
  }
  
  TfLiteTensor* output = interpreter.output(99); // invalid index
  
  if (output != nullptr) {
    return 2;
  }
  
  return 0;
}

// Main function that runs all tests
int main(int argc, char* argv[]) {
  tflite::InitializeTarget();
  
  int result = 0;
  
  if (test_init() != 0) { result = 1; }
  if (test_infer_non_spam() != 0) { result = 2; }
  if (test_infer_spam() != 0) { result = 3; }
  if (test_input_tensor_fail() != 0) { result = 4; }
  if (test_output_tensor_fail() != 0) { result = 5; }
  
  MicroPrintf("Test result: %d", result);
  if (result == 0) {
    MicroPrintf("All tests passed successfully!");
  }
  
  return result;
}
\end{lstlisting}

\chapter{Guia de Instalação e Configuração}\label{apendice:guia-instalacao}

\lstdefinestyle{terminal-abnt}{
    language={},                        
    backgroundcolor=\color{listbggray}, 
    basicstyle=\ttfamily\small,         
    keywordstyle=,                      % Estilo de keyword (vazio)
    stringstyle=,                       % Estilo de string (vazio)
    numbers=none,                       % Números de linha à esquerda
    numberstyle=\tiny,                  % Estilo do número (sem cor)
    numbersep=5pt,                      % Distância dos números
    frame=none,                         % Sem bordas (como no seu main.pdf)
    captionpos=t,                       % Posição da legenda (t = top), como no seu main.pdf
    breaklines=true,                    % Quebra linhas longas
    breakatwhitespace=true,             % Quebra apenas em espaços
    showstringspaces=false,             % Não mostra símbolos para espaços
    tabsize=2                           % Tamanho do TAB
}
\newtcblisting{abntbox}{
    enhanced,
    listing only,
    colback=listbggray,     
    colframe=listbggray,    
    arc=3mm,                
    left=2mm,
    right=2mm,
    top=2mm,
    bottom=2mm,
    fonttitle=\bfseries,
    coltitle=black,         
    listing options={style=terminal-abnt}
}

Este apêndice detalha os passos necessários para configurar o ambiente de desenvolvimento, isto envolve compilar o fork do Robcmp e replicar o sistema de build utilizado nos experimentos. 

No futuro, um novo desenvolvedor não precisará seguir estes passos pois o Robcmp já disponibilizará todas as possíveis bibliotecas pré-compiladas do \textit{wrapper} e do TFLM. Assim, o processo de desenvolvimento poderá ser feito através de forma automática e integrada ao PlatformIO, da mesma forma que já ocorre para programas embarcados convencionais. 

Porém, este apêndice ainda é valioso por ensinar o processo de instalação dos pacotes necessários, clonagem correta do repositório e compilação do Robcmp, tarefas obrigatórias para um novo desenvolvedor. Além disso, este conteúdo é útil para trabalhos futuros que desejem modificar o compilador Robcmp ou entender melhor sua integração com o TFLM.

\section{Pré-requisitos de Software}
Antes de iniciar, é necessário garantir que os seguintes pacotes de software estejam instalados no sistema (preferencialmente um ambiente Linux, como o Ubuntu):

\begin{itemize}
    \item Git: Para controle de versão e download do repositório.
    \item CMake: Para configurar o sistema de build do Robcmp.
    \item Make: Para executar os scripts de compilação e linkedição.
    \item LLVM (versão 20+): Conjunto de ferramentas e bibliotecas para compilação.
    \item Clang (versão 20+): Compilador C/C++ baseado no LLVM.
    \item Flex (versão 2.6.4 ou similar): Gerador de analisador léxico.
    \item Bison (versão 3.8.2 ou similar): Gerador de analisador sintático.
\end{itemize}

A maioria desses pacotes pode ser instalada em sistemas baseados em Debian/Ubuntu com os comandos:

% \begin{lstlisting}[style=terminal-abnt]
% sudo apt-get update
% sudo apt-get install git cmake make g++ flex bison
% \end{lstlisting}

\begin{abntbox}
sudo apt-get update
sudo apt-get install git cmake make clang llvm flex bison
\end{abntbox}

\section{Download do Repositório e Submódulos}
O fork do Robcmp utiliza submódulos do Git para gerenciar a dependência do TFLM. É necessário iniciar o submódulo existente após o clone com os seguintes comandos:

\begin{abntbox}
# Clona o repositorio fork do Robcmp
git clone https://github.com/LuizEduardoRezende/robcmp.git

# Navega ate o diretorio do repositorio
cd robcmp

# Seleciona a branch com o frontend do TFLM
git checkout tflm-front-end

# Inicializa e atualiza os submodulos
git submodule update --init --recursive
\end{abntbox}

Talvez seja necessário atualizar(\textit{refresh}) o seu explorador de arquivos para visualizar os novos arquivos criados, após a inicialização e atualização dos submódulos.

\section{Processo de Compilação (\textit{Build})}
O processo de compilação é dividido em duas etapas, conforme a arquitetura descrita na \hyperref[sec:arq-camada-compatibilidade]{Seção~\ref{sec:arq-camada-compatibilidade}}. Primeiro, compila-se a biblioteca estática do TFLM; em seguida, compila-se o Robcmp.

Caso esteja buscando compilar para uma arquitetura especifica (ex: Cortex-M4), é possível verificar todas as arquiteturas suportadas pelo TFLM na documentação do \textit{GitHub} \footnote{\url{https://github.com/tensorflow/tflite-micro/blob/main/tensorflow/lite/micro/cortex_m_generic/README.md}}.

Com uma arquitetura específica em mente, navegue até o diretório do submódulo do TFLM, depois use o sistema de Makefile do TFLM para compilar a biblioteca para a arquitetura desejada:

\begin{abntbox}
# Navega ate o diretorio do TFLM
cd third_party/tflite-micro/

# Compila para uma plataforma especifica
make -f tensorflow/lite/micro/tools/make/Makefile TARGET=cortex_m_generic TARGET_ARCH=cortex-m4 microlite

# Compila para a plataforma de sua maquina de desenvolvimento(linux, windows, etc)
make -f tensorflow/lite/micro/tools/make/Makefile microlite
\end{abntbox}

Ao final deste processo, a biblioteca estática com nome padronizado deverá estar presente no diretório \texttt{third-party/\allowbreak tflite-micro/\allowbreak gen/\allowbreak (nome-da-arquitetura)/\allowbreak lib/\allowbreak libtensorflow-microlite.a}. Talvez seja necessário atualizar(\textit{refresh}) o seu explorador de arquivos para visualizar os novos arquivos criados.

Atenção, caso tenha feito a compilação de mais de uma biblioteca estática do TFLM, escolha apenas uma arquitetura para trabalhar por vez. Para que o build e a configuração do ambiente de desenvolvimento ocorram corretamente é necessário que exista apenas uma arquitetura dentro de \texttt{third-party/tflite-micro/gen}. Caso deseje trabalhar com multiplas arquiteturas, é recomendado que se crie cópias do repositório do Robcmp para cada arquitetura desejada.

Com a biblioteca TFLM pronta, retorne ao diretório raiz do robcmp para compilar o projeto principal utilizando o CMake e o Make:

\begin{abntbox}
# Cria o diretorio de build e navega ate ele
mkdir build
cd build

# Configura o projeto
cmake ..

# Compila o projeto (use -j para compilacao paralela, ex: -j6)
make
\end{abntbox}

Se a compilação for bem-sucedida, o executável do compilador (arquivo \texttt{robcmp}) estará disponível dentro do diretório \texttt{build}, pronto para ser usado nos testes de validação.

\section{Compilação de arquivos .rob que usam o TFLM com Makefile}
    
Para conseguir compilar um programa \texttt{.rob} criado ou já existente basta utilizar o \texttt{Makefile} localizado no diretório \texttt{test/tflm-tests}. Este Makefile consegue compilar programas que estejam localizados dentro dessa mesma pasta. A partir desse diretório utilize os seguintes comandos:

\begin{abntbox}
# Mostra todos os comandos disponiveis 
make help

# Compila e executa todos os testes unitarios presentes na pasta
make

# Remove os arquivos objeto(.o) e executaveis gerados por programas
make clean

# Executa o programa que foi gerado na pasta out
./out/syntax-spam
\end{abntbox}

\end{anexosenv}

%---------------------------------------------------------------------
% INDICE REMISSIVO
%---------------------------------------------------------------------
%\phantompart
\printindex
%---------------------------------------------------------------------

\end{document}
